--- Plastimatch/src/plastimatch/standalone/gamma_gui.cpp	2016-08-10 00:01:45.606660524 +0200
+++ GitLabPlastimatch/src/plastimatch/standalone/gamma_gui.cpp	2016-08-10 00:54:10.309959646 +0200
@@ -1,4 +1,4 @@
-#include "gamma_gui.h"
+ï»¿#include "gamma_gui.h"
 #include <QString>
 #include <QFileDialog>
 #include <QListView>
@@ -30,6 +30,12 @@
 #include "dcmtk/dcmdata/dcitem.h"
 #include "dcmtk/dcmdata/dcdeftag.h"
 
+#include <QDataStream>
+#include "itkImageFileReader.h"
+#include "itkImageFileWriter.h"
+#include "itkImageSliceIteratorWithIndex.h"
+#include "itkFlipImageFilter.h"
+
 
 gamma_gui::gamma_gui(QWidget *parent, Qt::WFlags flags)
 : QMainWindow(parent, flags)
@@ -451,12 +457,20 @@
 
 void gamma_gui::SLTM_SaveBatchModeSimpleReport()
 {
-    QString fileName = QFileDialog::getSaveFileName(this, "Save batch report file", "", "report (*.txt)", 0, 0);
+    QString filePath = QFileDialog::getSaveFileName(this, "Save batch report file", m_strPathDirWorkDir, "report (*.txt)", 0, 0);
 
-    if (fileName.length() < 1)
+    if (filePath.length() < 1)
         return;
 
-    SaveBatchGamma3DSimpleReport(fileName);
+    QFileInfo fInfo(filePath);
+
+    if (fInfo.suffix() != "txt" && fInfo.suffix() != "TXT")
+    {
+        cout << "Saving filter didn't work. Saving this file as txt." << endl;
+        filePath = filePath + ".txt";
+    }
+
+    SaveBatchGamma3DSimpleReport(filePath);
 }
 
 
@@ -752,8 +766,8 @@
     if (iCnt < 1)
         return;
 
-    if (m_vRefDoseImages.size() != iCnt ||
-        m_vCompDoseImages.size() != iCnt)
+    if ((int)(m_vRefDoseImages.size()) != iCnt ||
+        (int)(m_vCompDoseImages.size()) != iCnt)
     {
         cout << "Error! iCnt not matching in DrawAll" << endl;
         return;
@@ -781,7 +795,7 @@
 
     FloatImageType::Pointer spCurGamma;
     
-      if (m_vGammaMapImages.size() == iCnt)
+      if ((int)(m_vGammaMapImages.size()) == iCnt)
           spCurGamma = m_vGammaMapImages.at(curIdx);
     /*if (m_pCurImageGamma3D)
         spCurGamma = m_spGammaMapImages;*/
@@ -799,7 +813,7 @@
     FloatImage2DType::Pointer spCurGamma2DFrom3D; 
     double finalPos1, finalPos2, finalPos3;
 
-    enPLANE curPlane;
+    enPLANE curPlane = PLANE_AXIAL;
     float fixedPos = 0.0;
 
     float probePos2D_X =0.0;
@@ -1084,7 +1098,7 @@
     float spacingX = pYKImg->m_fSpacingX;
     float spacingY = pYKImg->m_fSpacingY;
 
-    float iWidth = pYKImg->m_iWidth;
+    //float iWidth = pYKImg->m_iWidth;
     float iHeight = pYKImg->m_iHeight;
 
     float physPosX = 0.0;
@@ -1099,7 +1113,8 @@
     //Update Probe position
     // ui.lineEdit_ProbePosX
 
-    enPLANE curPlane;
+    enPLANE curPlane = PLANE_AXIAL;
+
     if (ui.radioButtonAxial->isChecked())
     {
         curPlane = PLANE_AXIAL;
@@ -1107,19 +1122,22 @@
         physPosX = crntDataPt.x()*spacingX + originX;
         physPosY = crntDataPt.y()*spacingY + originY;
 
-        ui.lineEdit_ProbePosX->setText(QString("%1").arg(physPosX));
-        ui.lineEdit_ProbePosY->setText(QString("%1").arg(physPosY));
-        //ui.lineEdit_ProbePosZ
+
+        ui.lineEdit_ProbePosX->setText(QString::number(physPosX, 'f', 1));
+        ui.lineEdit_ProbePosY->setText(QString::number(physPosY, 'f', 1));
+                //ui.lineEdit_ProbePosZ
     }
     else if (ui.radioButtonSagittal->isChecked())
     {
         curPlane = PLANE_SAGITTAL;
 
         physPosX = crntDataPt.x()*spacingX + originX;
-        physPosY = (iHeight - crntDataPt.y() - 1)*spacingY + originY;
+        physPosY = (iHeight - crntDataPt.y() - 1)*spacingY + originY;        
+
+        ui.lineEdit_ProbePosY->setText(QString::number(physPosX, 'f', 1));
+        ui.lineEdit_ProbePosZ->setText(QString::number(physPosY, 'f', 1));
+
 
-        ui.lineEdit_ProbePosY->setText(QString("%1").arg(physPosX));
-        ui.lineEdit_ProbePosZ->setText(QString("%1").arg(physPosY));
     }
     else if (ui.radioButtonFrontal->isChecked())
     {
@@ -1128,8 +1146,11 @@
         physPosX = crntDataPt.x()*spacingX + originX;
         physPosY = (iHeight - crntDataPt.y() - 1)*spacingY + originY;
 
-        ui.lineEdit_ProbePosX->setText(QString("%1").arg(physPosX));
-        ui.lineEdit_ProbePosZ->setText(QString("%1").arg(physPosY));
+        //ui.lineEdit_ProbePosX->setText(QString("%1").arg(physPosX));
+        //ui.lineEdit_ProbePosZ->setText(QString("%1").arg(physPosY));
+
+        ui.lineEdit_ProbePosX->setText(QString::number(physPosX, 'f', 1));
+        ui.lineEdit_ProbePosZ->setText(QString::number(physPosY, 'f', 1));
     }   
   
     
@@ -1226,7 +1247,7 @@
 
         if (bData2Exists)
         {
-            qreal tmpValX2 = vData2.at(i).x();
+            //qreal tmpValX2 = vData2.at(i).x();
             qreal tmpValY2 = vData2.at(i).y()*fMag2;
             qreal tmpValY2_Perc = vData2.at(i).y() / fNorm2 * 100.0; //fNorm : Gy not cGy            
 
@@ -1236,9 +1257,9 @@
 
         if (bData3Exists)
         {
-            qreal tmpValX3 = vData3.at(i).x();
+            //qreal tmpValX3 = vData3.at(i).x();
             qreal tmpValY3 = vData3.at(i).y()*fMag3;
-            qreal tmpValY3_Perc = vData3.at(i).y() / fNorm3 * 100.0; //fNorm : Gy not cGy
+            //qreal tmpValY3_Perc = vData3.at(i).y() / fNorm3 * 100.0; //fNorm : Gy not cGy
 
             strValY3 = QString::number(tmpValY3, 'f', 2); //gamma
         }       
@@ -1322,7 +1343,7 @@
 
     //QStandardItemModel 	m_pTableModel.item()
     int dataLen = m_pTableModel->rowCount();
-    int columnLen = m_pTableModel->columnCount();
+   // int columnLen = m_pTableModel->columnCount();
 
     if (dataLen < 1)
         return;
@@ -1862,10 +1883,10 @@
         return;
 
 
-    if (m_vRefDose.size() != iCnt ||
-        m_strlistPath_RD_Read_Ref.size() != iCnt ||
-        m_strlistPath_RD_Read_Comp.size() != iCnt ||
-        m_strlistPath_Output_Gammamap.size() != iCnt)
+    if ((int)m_vRefDose.size() != iCnt ||
+        (int)m_strlistPath_RD_Read_Ref.size() != iCnt ||
+        (int)m_strlistPath_RD_Read_Comp.size() != iCnt ||
+        (int)m_strlistPath_Output_Gammamap.size() != iCnt)
     {
         cout << "Error! SLT_WhenSelectCombo file count doesn't match!" << endl;
 
@@ -1878,9 +1899,9 @@
         return;
     }
         
-    if (m_vRefDoseImages.size() != iCnt ||
-        m_vCompDoseImages.size() != iCnt ||
-        m_vGammaMapImages.size() != iCnt)
+    if ((int)(m_vRefDoseImages.size()) != iCnt ||
+        (int)(m_vCompDoseImages.size()) != iCnt ||
+        (int)(m_vGammaMapImages.size()) != iCnt)
     {
         cout << "Error! ItkImage Pointer count doesn't match!" << endl;
         return;
@@ -1941,6 +1962,9 @@
     //SLT_DrawAll();
 }
 
+
+
+
 void gamma_gui::SLT_MouseWheelUpdateRef()
 {
     if (ui.labelReferDose->m_pYK16Image == NULL||
@@ -1949,6 +1973,23 @@
     {
         return;
     }
+
+    QComboBox* crntCombo = ui.comboBoxCompareFile;
+    int curIdx = crntCombo->currentIndex(); //this should be basename    
+
+    if (curIdx < 0)
+        return;
+
+    if (curIdx >= (int)(m_vRefDoseImages.size()))
+        return;
+
+    FloatImageType::Pointer spCurImg = m_vRefDoseImages.at(curIdx);
+
+    VEC3D ptLimitStart = { 0.0, 0.0, 0.0 };
+    VEC3D ptLimitEnd = { 0.0, 0.0, 0.0 };
+
+    QUTIL::GetGeometricLimitFloatImg(spCurImg, ptLimitStart, ptLimitEnd);
+
     if (ui.checkBox_ScrollZoom->isChecked())
     {
         double oldZoom = ui.labelReferDose->m_pYK16Image->m_fZoom;
@@ -1964,7 +2005,7 @@
     else //change slice
     {
         double fWeighting = 1.0;
-        enPLANE curPlane;
+        enPLANE curPlane = PLANE_AXIAL;
         float probePosX = ui.lineEdit_ProbePosX->text().toFloat();
         float probePosY = ui.lineEdit_ProbePosY->text().toFloat();
         float probePosZ = ui.lineEdit_ProbePosZ->text().toFloat();
@@ -1973,18 +2014,37 @@
         {
             curPlane = PLANE_AXIAL;
             probePosZ = probePosZ + ui.labelReferDose->m_iMouseWheelDelta*fWeighting;
+
+            if (probePosZ <= ptLimitStart.z)
+                probePosZ = ptLimitStart.z;
+
+            if (probePosZ >= ptLimitEnd.z)
+                probePosZ = ptLimitEnd.z;
+
+            
             ui.lineEdit_ProbePosZ->setText(QString::number(probePosZ, 'f', 1));
         }
         else if (ui.radioButtonSagittal->isChecked())
         {
             curPlane = PLANE_SAGITTAL;
             probePosX = probePosX + ui.labelReferDose->m_iMouseWheelDelta*fWeighting;
+            if (probePosX <= ptLimitStart.x)
+                probePosX = ptLimitStart.x;
+
+            if (probePosX >= ptLimitEnd.x)
+                probePosX = ptLimitEnd.x;            
+
             ui.lineEdit_ProbePosX->setText(QString::number(probePosX, 'f', 1));          
         }
         else if (ui.radioButtonFrontal->isChecked())
         {
             curPlane = PLANE_FRONTAL;
             probePosY = probePosY + ui.labelReferDose->m_iMouseWheelDelta*fWeighting;
+            if (probePosY <= ptLimitStart.y)
+                probePosY = ptLimitStart.y;
+            if (probePosY >= ptLimitEnd.y)
+                probePosY = ptLimitEnd.y;       
+
             ui.lineEdit_ProbePosY->setText(QString::number(probePosY, 'f', 1));
         }        
     }
@@ -2001,6 +2061,25 @@
         return;
     }
 
+    QComboBox* crntCombo = ui.comboBoxCompareFile;
+    int curIdx = crntCombo->currentIndex(); //this should be basename    
+
+    if (curIdx < 0)
+        return;
+
+    if (curIdx >= (int)(m_vRefDoseImages.size()))
+        return;
+
+    FloatImageType::Pointer spCurImg = m_vCompDoseImages.at(curIdx);
+
+    VEC3D ptLimitStart = { 0.0, 0.0, 0.0 };
+    VEC3D ptLimitEnd = { 0.0, 0.0, 0.0 };
+
+    QUTIL::GetGeometricLimitFloatImg(spCurImg, ptLimitStart, ptLimitEnd);
+
+
+
+
     if (ui.checkBox_ScrollZoom->isChecked())
     {
         double oldZoom = ui.labelCompDose->m_pYK16Image->m_fZoom;
@@ -2018,7 +2097,7 @@
     else //change slice
     {
         double fWeighting = 1.0;
-        enPLANE curPlane;
+        enPLANE curPlane = PLANE_AXIAL;
         float probePosX = ui.lineEdit_ProbePosX->text().toFloat();
         float probePosY = ui.lineEdit_ProbePosY->text().toFloat();
         float probePosZ = ui.lineEdit_ProbePosZ->text().toFloat();
@@ -2027,18 +2106,41 @@
         {
             curPlane = PLANE_AXIAL;
             probePosZ = probePosZ + ui.labelCompDose->m_iMouseWheelDelta*fWeighting;
+
+
+            if (probePosZ <= ptLimitStart.z)
+                probePosZ = ptLimitStart.z;
+
+            if (probePosZ >= ptLimitEnd.z)
+                probePosZ = ptLimitEnd.z;
+
+
+
             ui.lineEdit_ProbePosZ->setText(QString::number(probePosZ, 'f', 1));
         }
         else if (ui.radioButtonSagittal->isChecked())
         {
             curPlane = PLANE_SAGITTAL;
             probePosX = probePosX + ui.labelCompDose->m_iMouseWheelDelta*fWeighting;
+
+            if (probePosX <= ptLimitStart.x)
+                probePosX = ptLimitStart.x;
+
+            if (probePosX >= ptLimitEnd.x)
+                probePosX = ptLimitEnd.x;
+
             ui.lineEdit_ProbePosX->setText(QString::number(probePosX, 'f', 1));
         }
         else if (ui.radioButtonFrontal->isChecked())
         {
             curPlane = PLANE_FRONTAL;
             probePosY = probePosY + ui.labelCompDose->m_iMouseWheelDelta*fWeighting;
+
+            if (probePosY <= ptLimitStart.y)
+                probePosY = ptLimitStart.y;
+            if (probePosY >= ptLimitEnd.y)
+                probePosY = ptLimitEnd.y;
+
             ui.lineEdit_ProbePosY->setText(QString::number(probePosY, 'f', 1));
         }
     }
@@ -2061,6 +2163,22 @@
         return;
     }
 
+    QComboBox* crntCombo = ui.comboBoxCompareFile;
+    int curIdx = crntCombo->currentIndex(); //this should be basename    
+
+    if (curIdx < 0)
+        return;
+
+    if (curIdx >= (int)(m_vRefDoseImages.size()))
+        return;
+
+    FloatImageType::Pointer spCurImg = m_vGammaMapImages.at(curIdx);
+
+    VEC3D ptLimitStart = { 0.0, 0.0, 0.0 };
+    VEC3D ptLimitEnd = { 0.0, 0.0, 0.0 };
+
+    QUTIL::GetGeometricLimitFloatImg(spCurImg, ptLimitStart, ptLimitEnd);
+
     if (ui.checkBox_ScrollZoom->isChecked())
     {
         double oldZoom = ui.labelGammaMap3D->m_pYK16Image->m_fZoom;
@@ -2078,7 +2196,7 @@
     else //change slice
     {
         double fWeighting = 1.0;
-        enPLANE curPlane;
+        enPLANE curPlane = PLANE_AXIAL;
         float probePosX = ui.lineEdit_ProbePosX->text().toFloat();
         float probePosY = ui.lineEdit_ProbePosY->text().toFloat();
         float probePosZ = ui.lineEdit_ProbePosZ->text().toFloat();
@@ -2087,18 +2205,36 @@
         {
             curPlane = PLANE_AXIAL;
             probePosZ = probePosZ + ui.labelGammaMap3D->m_iMouseWheelDelta*fWeighting;
+
+            if (probePosZ <= ptLimitStart.z)
+                probePosZ = ptLimitStart.z;
+            if (probePosZ >= ptLimitEnd.z)
+                probePosZ = ptLimitEnd.z;
+
             ui.lineEdit_ProbePosZ->setText(QString::number(probePosZ, 'f', 1));
         }
         else if (ui.radioButtonSagittal->isChecked())
         {
             curPlane = PLANE_SAGITTAL;
             probePosX = probePosX + ui.labelGammaMap3D->m_iMouseWheelDelta*fWeighting;
+
+            if (probePosX <= ptLimitStart.x)
+                probePosX = ptLimitStart.x;
+            if (probePosX >= ptLimitEnd.x)
+                probePosX = ptLimitEnd.x;
             ui.lineEdit_ProbePosX->setText(QString::number(probePosX, 'f', 1));
         }
         else if (ui.radioButtonFrontal->isChecked())
         {
             curPlane = PLANE_FRONTAL;
             probePosY = probePosY + ui.labelGammaMap3D->m_iMouseWheelDelta*fWeighting;
+
+            if (probePosY <= ptLimitStart.y)
+                probePosY = ptLimitStart.y;
+            if (probePosY >= ptLimitEnd.y)
+                probePosY = ptLimitEnd.y;
+
+
             ui.lineEdit_ProbePosY->setText(QString::number(probePosY, 'f', 1));
         }
     }
@@ -2254,8 +2390,8 @@
     if (dataWidth*dataHeight == 0)
         return;
 
-    int dataX = qWnd->GetDataPtFromMousePos().x();
-    int dataY = qWnd->GetDataPtFromMousePos().y();
+   // int dataX = qWnd->GetDataPtFromMousePos().x();
+   // int dataY = qWnd->GetDataPtFromMousePos().y();
 
     ////Update offset information of dispImage
     //GetOriginalDataPos (PanStart)
@@ -2431,13 +2567,13 @@
         if (rc)
         {
             //DcmSequenceOfItems *seqFractionGroup = 0;
-            int iNumOfRefPlanSeq = seqRefPlan->card();
+            int iNumOfRefPlanSeq = (int)(seqRefPlan->card());
 
-            for (unsigned long i = 0; i < iNumOfRefPlanSeq; i++)
+            for (int i = 0; i < iNumOfRefPlanSeq; i++)
             {
                 OFCondition orc;
 
-                const char *strVal = 0;
+               // const char *strVal = 0;
 
                 DcmItem *itemRefPlan = seqRefPlan->getItem(i);
 
@@ -2498,10 +2634,10 @@
         //cout << "iBeamNumber " << iValBeamNumber << endl;
 
         QString strFractionGroupNumber;
-        strFractionGroupNumber = strFractionGroupNumber.sprintf("%02d", iValFractionGroupNumber);
+        strFractionGroupNumber = strFractionGroupNumber.sprintf("%02d", (int)iValFractionGroupNumber);
 
         QString strBeamNumber;
-        strBeamNumber = strBeamNumber.sprintf("%03d", iValBeamNumber);
+        strBeamNumber = strBeamNumber.sprintf("%03d", (int)iValBeamNumber);
 
         QFileInfo fileInfo = QFileInfo(crntFilePath);
         QDir dir = fileInfo.absoluteDir();
@@ -2837,7 +2973,6 @@
     SetWorkDir(dirPath);
 }
 
-
 void gamma_gui::SetWorkDir(const QString& strPath)
 {
     m_strPathDirWorkDir = strPath;
@@ -2846,10 +2981,373 @@
 
 void gamma_gui::SLTM_ExportBatchReport()
 {
-    QString fileName = QFileDialog::getSaveFileName(this, "Save batch report file", m_strPathDirWorkDir, "report (*.txt)", 0, 0);
+    QString filePath = QFileDialog::getSaveFileName(this, "Save batch report file", m_strPathDirWorkDir, "report (*.txt)", 0, 0);
+
+    if (filePath.length() < 1)
+        return;
+
+
+    QFileInfo fInfo(filePath);
+
+    if (fInfo.suffix() != "txt" && fInfo.suffix() != "TXT")
+    {
+        cout << "Saving filter didn't work. Saving this file as txt." << endl;
+        filePath = filePath + ".txt";
+    }
+
+    SaveBatchGamma3DSimpleReport(filePath);
+}
+
+void gamma_gui::SLTM_LoadProtonDoseSetFile()
+{   
+    QStringList tmpList = QFileDialog::getOpenFileNames(this, "Select proton dose set file to open", m_strPathDirWorkDir, "Proton dose set file (*.set)");
 
-    if (fileName.length() < 1)
+    int iFileCnt = tmpList.size();
+    if (iFileCnt < 1)
+        return;
+
+    vector<ProtonSetFileMGH> vProtonSetHeader;
+
+    for (int i = 0; i < iFileCnt; i++)
+    {
+        QString curTextSetFilePath = tmpList.at(i);
+        
+        ProtonSetFileMGH tmpProtonSetHeader;
+        //Read text and fill the class with as it is.
+        if (!ReadProtonDoseSet(curTextSetFilePath, tmpProtonSetHeader)) //Only reading text files to fill up the vectors, without any auditing
+        {
+            //do nothing            
+        }
+
+        cout << "FilePathRef= " << tmpProtonSetHeader.strPathRefDose.toLocal8Bit().constData() << endl;
+        cout << "FilePathComp= " << tmpProtonSetHeader.strPathCompDose.toLocal8Bit().constData() << endl;
+
+        QFileInfo fInfoRef(tmpProtonSetHeader.strPathRefDose);
+        QFileInfo fInfoComp(tmpProtonSetHeader.strPathCompDose);
+
+        if (fInfoRef.exists() && fInfoComp.exists()) //both files should exists.
+        {
+            vProtonSetHeader.push_back(tmpProtonSetHeader);
+        }        
+    }
+
+    if (vProtonSetHeader.empty())
+    {
+        cout << "Error. No file was found" << endl;
         return;
+    }
+
+
+    //Ref clear
+    ui.plainTextEdit_RD_Ref->clear();
+    m_strlistPath_RD_Original_Ref.clear();
+    m_strlistFileBaseName_Ref.clear();
+
+    //Comp Clear
+    ui.plainTextEdit_RD_Comp->clear();    
+    m_strlistPath_RD_Original_Comp.clear();    
+    m_strlistFileBaseName_Comp.clear();
+
+    //output clear
+    m_strlistPath_Output_Gammamap.clear();    
+    m_strlistPath_Output_Failure.clear();
+    m_strlistPath_Output_Report.clear();
+    m_strlistBatchReport.clear();
+
+    //Ref dose clear;
+    m_vRefDose.clear();   
+
+    //Conversion
+    vector<ProtonSetFileMGH>::iterator it;
+    for (it = vProtonSetHeader.begin(); it != vProtonSetHeader.end(); ++it)
+    {
+        ProtonSetFileMGH tempDoseSet = (*it);
+
+        QString strPathMhaRef = ConvertMGHProtonDoseToMha(tempDoseSet.strPathRefDose, tempDoseSet.fDim, tempDoseSet.fOrigin, tempDoseSet.fSpacing);
+        QString strPathMhaComp = ConvertMGHProtonDoseToMha(tempDoseSet.strPathCompDose, tempDoseSet.fDim, tempDoseSet.fOrigin, tempDoseSet.fSpacing);
+
+        QFileInfo fInfoMhaRef(strPathMhaRef);
+        QFileInfo fInfoMhaComp(strPathMhaComp);
+
+        if (fInfoMhaRef.exists())
+        {            
+            m_strlistPath_RD_Original_Ref.push_back(strPathMhaRef);            
+            m_strlistFileBaseName_Ref.push_back(fInfoMhaRef.completeBaseName());
+            ui.plainTextEdit_RD_Ref->appendPlainText(strPathMhaRef); //just for display            
+        }        
+
+        if (fInfoMhaComp.exists())
+        {
+            m_strlistPath_RD_Original_Comp.push_back(strPathMhaComp);            
+            m_strlistFileBaseName_Comp.push_back(fInfoMhaComp.completeBaseName());
+            ui.plainTextEdit_RD_Comp->appendPlainText(strPathMhaComp); //just for display            
+        }
+    }          
+
+    if (m_strlistPath_RD_Original_Ref.size() > 0)
+    {
+        QFileInfo finfo(m_strlistPath_RD_Original_Ref.at(0));
+        QDir crntDir = finfo.absoluteDir();
+        m_strPathInputDir = crntDir.absolutePath();
+
+        SetWorkDir(m_strPathInputDir); //optional
+
+        //Change the plane to Frontal
+        ui.radioButtonFrontal->setChecked(true);
+    }     
+}
+
+bool gamma_gui::ReadProtonDoseSet(QString& strPathProtonDoseSet, ProtonSetFileMGH& protonSetInfo) //strPathProtonDoseSet text file
+{
+    //protonSetInfo    
+
+    /*protonSetInfo.fDim = { 1.0, 1.0, 1.0 };
+    protonSetInfo.fOrigin = { 0.0, 0.0, 0.0 };
+    protonSetInfo.fSpacing = { 1.0, 1.0, 1.0 };*/
+
+    protonSetInfo.fDim.x = 1.0;
+    protonSetInfo.fDim.y = 1.0;
+    protonSetInfo.fDim.z = 1.0;
+
+    protonSetInfo.fOrigin.x = 0.0;
+    protonSetInfo.fOrigin.y = 0.0;
+    protonSetInfo.fOrigin.z = 0.0;
+
+    protonSetInfo.fSpacing.x = 1.0;
+    protonSetInfo.fSpacing.y = 1.0;
+    protonSetInfo.fSpacing.z = 1.0;
+
+    protonSetInfo.strCTDir = "";
+    protonSetInfo.strPathRefDose = "";
+    protonSetInfo.strPathCompDose = "";
+
+
+    QFileInfo fInfoBase(strPathProtonDoseSet);
+
+    ifstream fin;
+    fin.open(strPathProtonDoseSet.toLocal8Bit().constData());
+
+    if (fin.fail())
+    {
+        cout << "Error occurred in file reading!" << endl;
+        return false;
+    } 
+
+    char str[MAX_LINE_LENGTH];
+
+    while (!fin.eof())
+    {
+        memset(str, 0, MAX_LINE_LENGTH);
+        fin.getline(str, MAX_LINE_LENGTH);
+
+        QString tmpStrLine = QString(str);
+        QStringList strListData = tmpStrLine.split(" \"");
+
+        QString strHeader, strData;
+        if (strListData.count() == 2)
+        {
+            strHeader = strListData.at(0);
+            strData = strListData.at(1);
+            strData = strData.remove("\"");
+        }        
+        strData = strData.trimmed(); //very important for Linux system!!!!!
+
+
+
+        if (strHeader.contains("calc-vol"))
+        {           
+
+            QStringList strlistVolInfo = strData.split(",");
+            if (strlistVolInfo.count() == 9) //should be
+            {
+                //First 3 digits: size in mm. X (Lat), Y(SI), Z(AntPost), IEC
+                VEC3D fLength, fOrigin, fDim, fSpacing;
+
+                fLength.x = strlistVolInfo.at(0).toDouble();
+                fLength.y = strlistVolInfo.at(1).toDouble();
+                fLength.z = strlistVolInfo.at(2).toDouble();
+
+                fOrigin.x = strlistVolInfo.at(3).toDouble();
+                fOrigin.y = strlistVolInfo.at(4).toDouble();
+                fOrigin.z = strlistVolInfo.at(5).toDouble();
+
+                fDim.x = strlistVolInfo.at(6).toDouble();
+                fDim.y = strlistVolInfo.at(7).toDouble();
+                fDim.z = strlistVolInfo.at(8).toDouble();
+
+                if (fDim.x != 0 && fDim.y != 0 && fDim.z != 0)
+                {
+                    fSpacing.x = fLength.x / fDim.x;
+                    fSpacing.y = fLength.y / fDim.y;
+                    fSpacing.z = fLength.z / fDim.z;
+                }
+                else
+                {
+                    fSpacing.x = 1.0;
+                    fSpacing.y = 1.0;
+                    fSpacing.z = 1.0;                    
+                }
 
-    SaveBatchGamma3DSimpleReport(fileName); 
+                protonSetInfo.fDim = fDim;
+                protonSetInfo.fOrigin = fOrigin;
+                protonSetInfo.fSpacing = fSpacing;
+            }
+        }
+        else if (strHeader.contains("ct-dir"))
+        {
+            protonSetInfo.strCTDir = strData;
+        }
+        else if (strHeader.trimmed() == "dose")
+        {            
+            strData = strData + ".MC";                        
+            protonSetInfo.strPathCompDose = fInfoBase.absolutePath() + "/" +strData;
+        }
+        else if (strHeader.trimmed() == "ref-dose")
+        {
+            strData = strData + ".orig";            
+            protonSetInfo.strPathRefDose = fInfoBase.absolutePath() + "/" + strData;
+        }
+    }
+    fin.close();
+
+    return true;
+}
+
+QString gamma_gui::ConvertMGHProtonDoseToMha(QString& strPathBinary, VEC3D& fDim, VEC3D& fOrigin, VEC3D& fSpacing)
+{
+    QString strResult = "";
+    ///Create a mha file
+
+    QFileInfo fInfo(strPathBinary);
+
+    if (!fInfo.exists())
+    {
+        cout << "Cannot find the binary file: " << strPathBinary.toLocal8Bit().constData() << endl;
+        return strResult;
+    }
+
+    QFile binFile(strPathBinary);
+    binFile.open(QIODevice::ReadOnly);
+    QDataStream in(&binFile);    
+    in.setByteOrder(QDataStream::BigEndian);
+
+    //qint32 voxData;
+    quint32 voxData;
+
+    //Coordinate conversion: IEC --> DICOM --> not possible!
+    //fDim = IEC
+    int width_DCM = (int)fDim.x; //
+    int height_DCM = (int)fDim.z; //
+    int length_DCM = (int)fDim.y; //
+
+    //Create a float itk image 3D
+    FloatImageType::Pointer spItkFloat = FloatImageType::New();
+
+    FloatImageType::SizeType size;
+    size[0] = width_DCM;
+    size[1] = height_DCM;
+    size[2] = length_DCM;
+
+    FloatImageType::IndexType idxStart;
+    idxStart[0] = 0;
+    idxStart[1] = 0;
+    idxStart[2] = 0;
+
+    FloatImageType::SpacingType spacing;    
+    spacing[0] = fSpacing.x;
+    spacing[1] = fSpacing.z;
+    spacing[2] = fSpacing.y;    
+
+    FloatImageType::PointType origin;
+    origin[0] = fOrigin.x;
+    origin[1] = -fOrigin.z;
+    origin[2] = fOrigin.y;
+
+    FloatImageType::RegionType region;
+    region.SetSize(size);
+    region.SetIndex(idxStart);
+
+    spItkFloat->SetRegions(region);
+    spItkFloat->SetSpacing(spacing);
+    spItkFloat->SetOrigin(origin);
+    spItkFloat->Allocate();
+
+    /*ofstream fout;
+    fout.open("D:/testDoseOut.txt");*/
+
+    //itk::ImageRegionIterator<FloatImageType> it(spItkFloat, spItkFloat->GetLargestPossibleRegion());
+    itk::ImageSliceIteratorWithIndex<FloatImageType> it(spItkFloat, spItkFloat->GetLargestPossibleRegion());
+    it.SetFirstDirection(0); //dicom x
+    it.SetSecondDirection(2); //dicom z. -2 doesn't work
+
+    it.GoToBegin();          
+    
+    //for (int k = 3; k < 4; k++)
+    float doseGyVal = 0.0;
+    for (int k = 0; k < height_DCM && !it.IsAtEnd(); k++)
+    {
+        for (int i = 0; i < length_DCM && !it.IsAtEndOfSlice(); i++) //coronal plane
+        {
+            for (int j = 0; j < width_DCM && !it.IsAtEndOfLine(); j++)
+            {
+                //converted mha file: Gy, float //current file: cGy, uint
+                in >> voxData;
+                doseGyVal = voxData / 100.0; //cGy to Gy
+                it.Set(doseGyVal);
+                ++it;                                            
+                //    fout << voxData << ",";
+            }
+            it.NextLine();
+          //  fout << endl;
+        }
+        it.NextSlice();
+        //fout << "Plane=" << k << endl;
+    }
+    binFile.close();
+
+    typedef itk::FlipImageFilter< FloatImageType >  FilterType;
+    FilterType::Pointer flipFilter = FilterType::New();
+    typedef FilterType::FlipAxesArrayType FlipAxesArrayType;
+
+    FlipAxesArrayType arrFlipAxes;
+    arrFlipAxes[0] = 0;
+    arrFlipAxes[1] = 0;
+    arrFlipAxes[2] = 1;//SI flip
+
+    flipFilter->SetFlipAxes(arrFlipAxes);
+    flipFilter->SetInput(spItkFloat); //plan CT, USHORT image
+    flipFilter->Update();
+
+    spItkFloat = flipFilter->GetOutput();
+    spItkFloat->SetOrigin(origin); //origin was reverted after the flipping
+    
+
+    QString strDirPath = fInfo.absolutePath();
+    QString strFileName = fInfo.fileName() + ".mha";
+    strResult = strDirPath + "/" + strFileName;
+
+    typedef itk::ImageFileWriter<FloatImageType> WriterType;
+    WriterType::Pointer writer = WriterType::New();
+
+    writer->SetFileName(strResult.toLocal8Bit().constData());
+    writer->SetUseCompression(true); //not exist in original code (rtkfdk)	
+    writer->SetInput(spItkFloat);
+    writer->Update();
+
+    //cout << "Writing image file was succeeded: " << strPath.toLocal8Bit().constData() << endl;
+    //fout.close();
+
+    QFileInfo fInfoOut(strResult);
+
+    if (!fInfoOut.exists())
+    {
+        strResult = "";
+        cout << "Error!File conversion failed" << endl;
+    }
+    else
+        cout << "Successfully converted to a mha file:" << strResult.toLocal8Bit().constData() <<endl;
+     
+    
+    
+    return strResult;
 }
