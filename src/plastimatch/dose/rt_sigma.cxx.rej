--- Plastimatch/src/plastimatch/dose/rt_sigma.cxx	2016-08-10 00:01:45.583327191 +0200
+++ GitLabPlastimatch/src/plastimatch/dose/rt_sigma.cxx	2016-08-10 00:54:10.283292978 +0200
@@ -107,9 +107,9 @@
     float energy)
 {
     float sigma_max = 0;
-	int dim[3] = {sigma_vol->get_vol()->dim[0],  sigma_vol->get_vol()->dim[1], sigma_vol->get_vol()->dim[2]};
-	int dim_rpl[3] = {rpl_vol->get_vol()->dim[0], rpl_vol->get_vol()->dim[1], rpl_vol->get_vol()->dim[2]};
-	int idx = 0;
+    const plm_long *dim = sigma_vol->get_vol()->dim;
+    const plm_long *dim_rpl = rpl_vol->get_vol()->dim;
+    int idx = 0;
 
     if (dim[0] != dim_rpl[0] || dim[1] != dim_rpl[1] || dim[2] != dim_rpl[2])
     {
@@ -121,7 +121,7 @@
     float* rpl_img = (float*) rpl_vol->get_vol()->img;
     unsigned char* ap_img = NULL;
 
-	double x_over_range = 0;
+    double x_over_range = 0;
 	
     if (rpl_vol->get_aperture()->have_aperture_image())
     {
@@ -137,41 +137,41 @@
     /* Calculation of the sigma values from the medium equivalent depth  */
     for (int i = 0; i < dim[0] * dim [1]; i++)
     {
-		for (int k = 0; k < dim[2]; k++)
-		{
-			idx = k * dim[0] * dim[1] +i;
-			if (!rpl_vol->get_aperture()->have_aperture_image() || (rpl_vol->get_aperture()->have_aperture_image() && ap_img[i] > 0))
-			{
-				if (rpl_img[idx] <= 0) 
-				{
-					sigma_volume[idx] = 0;
-				}
-				else if (rpl_img[idx] >= range)
-				{
-					sigma_volume[idx] = sigma0 * sigma0; // sigma will contains the square of the sigmas to do the quadratic sum
+        for (int k = 0; k < dim[2]; k++)
+        {
+            idx = k * dim[0] * dim[1] +i;
+            if (!rpl_vol->get_aperture()->have_aperture_image() || (rpl_vol->get_aperture()->have_aperture_image() && ap_img[i] > 0))
+            {
+                if (rpl_img[idx] <= 0) 
+                {
+                    sigma_volume[idx] = 0;
+                }
+                else if (rpl_img[idx] >= range)
+                {
+                    sigma_volume[idx] = sigma0 * sigma0; // sigma will contains the square of the sigmas to do the quadratic sum
             
-					/* sigma_max update */
-					if (sigma0 > sigma_max)
-					{
-						sigma_max = sigma0;
-					}
-				}
-				else
-				{
-					x_over_range = rpl_img[idx] / range;
+                    /* sigma_max update */
+                    if (sigma0 > sigma_max)
+                    {
+                        sigma_max = sigma0;
+                    }
+                }
+                else
+                {
+                    x_over_range = rpl_img[idx] / range;
 
-					/* sigma = y0 * Hong (x/range) */
-					sigma_volume[idx] = sigma0 * x_over_range * ( 0.26232 + 0.64298 * x_over_range + 0.0952393 * x_over_range * x_over_range);
+                    /* sigma = y0 * Hong (x/range) */
+                    sigma_volume[idx] = sigma0 * x_over_range * ( 0.26232 + 0.64298 * x_over_range + 0.0952393 * x_over_range * x_over_range);
             
-					/* sigma_max update */
-					if (sigma_volume[idx] > sigma_max)
-					{
-						sigma_max = sigma_volume[idx];
-					}
-					sigma_volume[idx] *= sigma_volume[idx]; // We return sigma^2 to sigma_vol
-				}
-			}
-		}
+                    /* sigma_max update */
+                    if (sigma_volume[idx] > sigma_max)
+                    {
+                        sigma_max = sigma_volume[idx];
+                    }
+                    sigma_volume[idx] *= sigma_volume[idx]; // We return sigma^2 to sigma_vol
+                }
+            }
+        }
     }
     return sigma_max;
 }
