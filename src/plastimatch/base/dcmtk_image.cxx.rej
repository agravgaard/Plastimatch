--- Plastimatch/src/plastimatch/base/dcmtk_image.cxx	2016-08-10 00:01:45.553327191 +0200
+++ GitLabPlastimatch/src/plastimatch/base/dcmtk_image.cxx	2016-08-10 00:54:10.246626313 +0200
@@ -22,12 +22,12 @@
 #include "logfile.h"
 #include "rt_study_metadata.h"
 #include "plm_image.h"
-#include "plm_image_set.h"
 #include "plm_image_header.h"
 #include "plm_math.h"
 #include "plm_uid_prefix.h"
 #include "plm_version.h"
 #include "print_and_exit.h"
+#include "slice_list.h"
 #include "string_util.h"
 #include "volume.h"
 
@@ -35,115 +35,248 @@
 Dcmtk_loader::image_load ()
 {
     /* Set up outputs */
-    Plm_image_set::Pointer pli_set = Plm_image_set::New();
     Plm_image::Pointer pli = Plm_image::New();
     d_ptr->img = pli;
 
     /* Make abbreviations */
     Dcmtk_series *ds_image = d_ptr->ds_image;
-    const Dcmtk_file_list& flist = ds_image->get_flist ();
+    const Dcmtk_file_list& ds_flist = ds_image->get_flist ();
 
     /* Create a container to hold different groups of files */
     std::list<Dcmtk_file_list> group_list;
 
-    /* Insert files into groups according to direction cosines */
+    /* Arrange files into groups according to direction cosines */
+    for (Dcmtk_file_list::const_iterator it = ds_flist.begin();
+         it != ds_flist.end(); ++it)
     {
-        //printf ("----------\n");
-        Dcmtk_file_list::const_iterator it;
-        for (it = flist.begin(); it != flist.end(); ++it) {
-            const Dcmtk_file::Pointer& df = (*it);
-
-            //df->debug ();
-
-            bool match_found = false;
-            std::list<Dcmtk_file_list>::iterator grit;
-            for (grit = group_list.begin(); grit != group_list.end(); ++grit) {
-                Dcmtk_file_list& flp = *grit;
-                const Dcmtk_file::Pointer& flp_df = flp.front();
-
-                if (flp_df->get_direction_cosines() 
-                    == df->get_direction_cosines())
-                {
-                    /* Add logic to append to flp */
-                    //printf ("Match found.  :)\n");
-                    match_found = true;
-                    flp.push_back (df);
-                    break;
-                }
-            }
-            if (match_found) {
-                continue;
+        const Dcmtk_file::Pointer& df = (*it);
+        bool match_found = false;
+        std::list<Dcmtk_file_list>::iterator grit;
+        for (grit = group_list.begin(); grit != group_list.end(); ++grit) {
+            Dcmtk_file_list& flp = *grit;
+            const Dcmtk_file::Pointer& flp_df = flp.front();
+
+            if (flp_df->get_direction_cosines() 
+                == df->get_direction_cosines())
+            {
+                /* Add logic to append to flp */
+                //printf ("Match found.  :)\n");
+                match_found = true;
+                flp.push_back (df);
+                break;
             }
-            /* Else insert new element into group_list */
-            //printf ("Need to insert.\n");
-            group_list.push_back (Dcmtk_file_list());
-            group_list.back().push_back (df);
         }
-        //printf ("----------\n");
+        if (match_found) {
+            continue;
+        }
+        /* Else insert new element into group_list */
+        group_list.push_back (Dcmtk_file_list());
+        group_list.back().push_back (df);
     }
 
-    /* Sort each group in Z direction */
-    {
+    /* If multiple groups, emit a warning.  Choose the largest group. */
+    Dcmtk_file_list *flist = &group_list.front ();
+    if (group_list.size() > 1) {
+        lprintf ("Warning, DICOM series with multiple direction cosines\n");
         std::list<Dcmtk_file_list>::iterator grit;
         for (grit = group_list.begin(); grit != group_list.end(); ++grit) {
-            grit->sort();
+            if ((*grit).size() > flist->size()) {
+                flist = &*grit;
+            }
         }
     }
+    
+    /* Sort group in Z direction */
+    flist->sort (dcmtk_file_compare_z_position);
 
-    /* Regroup as needed according to inter-slice spacing */
-    {
-    }
-
-    /* Sort in Z direction */
-    ds_image->sort ();
-
-    /* GCS FIX:
-       (1) Direction cosines
-       (2) Minimum 2 slices
-       (3) Consistency of images w/in series
-       (4) done
-       (5) Different image types
-       (6) Refine slice spacing based on entire chunk size
-    */
+    /* 
+     * GCS FIX:
+     * Remove minimum 2 slices requirement
+     * Check consistency (dim, origin) of images w/in series
+     * Different image types
+     * Refine slice spacing based on entire chunk size
+     */
 
     /* Check for minimum 2 slices */
-    if (flist.size() < 2) {
+    if (flist->size() < 2) {
         return;
     }
-    
+
     /* Get first slice */
-    std::list<Dcmtk_file::Pointer>::const_iterator it = flist.begin();
-    const Dcmtk_file* df = (*it).get();
-    float z_init, z_prev, z_diff, z_last;
-    int slice_no = 0;
-    float best_chunk_z_start = z_init = z_prev = df->get_z_position ();
+    const Dcmtk_file* df = (*flist->begin()).get();
     
     /* Store UIDs */
-    if (d_ptr->m_drs) {
-        d_ptr->m_drs->set_ct_series_uid (
+    if (d_ptr->rt_meta) {
+        d_ptr->rt_meta->set_ct_series_uid (
             df->get_cstr (DCM_SeriesInstanceUID));
-        d_ptr->m_drs->set_frame_of_reference_uid (
+        d_ptr->rt_meta->set_frame_of_reference_uid (
             df->get_cstr (DCM_FrameOfReferenceUID));
-        d_ptr->m_drs->set_study_uid (
+        d_ptr->rt_meta->set_study_uid (
             df->get_cstr (DCM_StudyInstanceUID));
-        d_ptr->m_drs->set_study_date (
+        d_ptr->rt_meta->set_study_date (
             df->get_cstr (DCM_StudyDate));
-        d_ptr->m_drs->set_study_time (
+        d_ptr->rt_meta->set_study_time (
             df->get_cstr (DCM_StudyTime));
 
         /* Store remaining metadata */
-        Metadata::Pointer& study_metadata = d_ptr->m_drs->get_study_metadata ();
+        Metadata::Pointer& study_metadata = d_ptr->rt_meta->get_study_metadata ();
         dcmtk_copy_into_metadata (study_metadata, df, DCM_PatientName);
         dcmtk_copy_into_metadata (study_metadata, df, DCM_PatientID);
         dcmtk_copy_into_metadata (study_metadata, df, DCM_PatientSex);
         dcmtk_copy_into_metadata (study_metadata, df, DCM_PatientPosition);
         dcmtk_copy_into_metadata (study_metadata, df, DCM_StudyID);
 
-        Metadata::Pointer& image_metadata = d_ptr->m_drs->get_image_metadata ();
+        Metadata::Pointer& image_metadata = d_ptr->rt_meta->get_image_metadata ();
         dcmtk_copy_into_metadata (image_metadata, df, DCM_Modality);
     }
 
-    /* Get next slice */
+    /* Divine image type */
+    uint16_t samp_per_pix, bits_alloc, bits_stored, high_bit, pixel_rep;
+    const char* phot_interp;
+    bool rc = df->get_uint16 (DCM_SamplesPerPixel, &samp_per_pix);
+    if (!rc) {
+        return;
+    }
+    phot_interp = df->get_cstr (DCM_PhotometricInterpretation);
+    if (!phot_interp) {
+        return;
+    }
+    rc = df->get_uint16 (DCM_BitsAllocated, &bits_alloc);
+    if (!rc) {
+        return;
+    }
+    rc = df->get_uint16 (DCM_BitsStored, &bits_stored);
+    if (!rc) {
+        return;
+    }
+    rc = df->get_uint16 (DCM_HighBit, &high_bit);
+    if (!rc) {
+        return;
+    }
+    rc = df->get_uint16 (DCM_PixelRepresentation, &pixel_rep);
+    if (!rc) {
+        return;
+    }
+
+    float rescale_slope, rescale_intercept;
+    rc = df->get_ds_float (DCM_RescaleIntercept, &rescale_intercept);
+    if (!rc) {
+        rescale_intercept = 0;
+    }
+    rc = df->get_ds_float (DCM_RescaleSlope, &rescale_slope);
+    if (!rc) {
+        rescale_slope = 1;
+    }
+
+#if defined (commentout)
+    lprintf ("Samp_per_pix: %d\n", (int) samp_per_pix);
+    lprintf ("Phot_interp: %s\n", phot_interp);
+    lprintf ("Bits_alloc: %d\n", (int) bits_alloc);
+    lprintf ("Bits_stored: %d\n", (int) bits_stored);
+    lprintf ("High_bit: %d\n", (int) high_bit);
+    lprintf ("Pixel_rep: %d\n", (int) pixel_rep);
+    lprintf ("S/I = %f/%f\n", rescale_slope, rescale_intercept);
+#endif
+    
+    /* Some kinds of images we don't know how to deal with.  
+       Don't load these. */
+    if (samp_per_pix != 1) {
+        lprintf ("Sorry, couldn't load image: samp_per_pix\n");
+        return;
+    }
+    if (strcmp (phot_interp, "MONOCHROME2")) {
+        lprintf ("Sorry, couldn't load image: phot_interp\n");
+        return;
+    }
+    if (bits_alloc != 16 && bits_alloc != 8) {
+        lprintf ("Sorry, couldn't load image: bits_alloc\n");
+        return;
+    }
+    if (bits_stored != high_bit + 1) {
+        lprintf ("Sorry, couldn't load image: bits_stored/high_bit\n");
+        return;
+    }
+    if (pixel_rep != 0 && pixel_rep != 1) {
+        lprintf ("Sorry, couldn't load image: pixel_rep\n");
+        return;
+    }
+
+    /* If PLM_CONFIG_VOL_LIST is enabled, the image will be loaded 
+       into a PLM_IMG_TYPE_GPUIT_LIST */
+#if (PLM_CONFIG_VOL_LIST)
+
+    /* Get first slice of group */
+    Dcmtk_file_list::iterator it = flist->begin();
+    df = it->get();
+
+    /* Get next slice in group */
+    float z_init, z_prev, z_diff, z_last;
+    int slice_no = 0;
+    float best_chunk_z_start = z_init = z_prev = df->get_z_position ();
+
+    ++it; ++slice_no;
+    df = (*it).get();
+    z_diff = df->get_z_position() - z_prev;
+    z_last = z_prev = df->get_z_position();
+
+    /* We want to find the number and spacing for each chunk 
+       within the group.  These are used to set the dim and 
+       spacing of the volume. */
+    int this_chunk_start = 0, best_chunk_start = 0;
+    float this_chunk_diff = z_diff, best_chunk_diff = z_diff;
+    int this_chunk_len = 2, best_chunk_len = 2;
+
+    /* Loop through remaining slices */
+    while (++it != flist->end())
+    {
+        ++slice_no;
+        printf ("Slice no: %d\n", slice_no);
+        df = (*it).get();
+        z_diff = df->get_z_position() - z_prev;
+        z_last = z_prev = df->get_z_position();
+
+        if (fabs (this_chunk_diff - z_diff) > 0.11) {
+            /* Start a new chunk if difference in thickness is 
+               more than 0.1 millimeter */
+            this_chunk_start = slice_no - 1;
+            this_chunk_len = 2;
+            this_chunk_diff = z_diff;
+        } else {
+            /* Same thickness, increase size of this chunk */
+            this_chunk_diff = ((this_chunk_len * this_chunk_diff) + z_diff)
+                / (this_chunk_len + 1);
+            this_chunk_len++;
+
+            /* Check if this chunk is now the best chunk */
+            if (this_chunk_len > best_chunk_len) {
+                best_chunk_start = this_chunk_start;
+                best_chunk_len = this_chunk_len;
+                best_chunk_diff = this_chunk_diff;
+                best_chunk_z_start = z_prev 
+                    - (best_chunk_len-1) * best_chunk_diff;
+            }
+        }
+    }
+
+#if defined (commentout)        
+    Dcmtk_file_list& flp = *grit;
+    const Dcmtk_file::Pointer dfp = grit->front();
+    Volume::Pointer vol = Volume::New (
+        const plm_long dim[3], 
+        const float origin[3], 
+        const float spacing[3], 
+        &dfp->get_direction_cosines(),
+        vh,
+        PT_FLOAT, 1);
+#endif
+
+#else /* NOT VOL_LIST */
+    /* Get next slice in first chunk */
+    float z_init, z_prev, z_diff, z_last;
+    int slice_no = 0;
+    float best_chunk_z_start = z_init = z_prev = df->get_z_position ();
+
+    std::list<Dcmtk_file::Pointer>::const_iterator it = flist->begin();
     ++it; ++slice_no;
     df = (*it).get();
     z_diff = df->get_z_position() - z_prev;
@@ -153,10 +286,10 @@
        be used to resample in the case of irregular spacing. */
     int this_chunk_start = 0, best_chunk_start = 0;
     float this_chunk_diff = z_diff, best_chunk_diff = z_diff;
-    int this_chunk_len = 2, best_chunk_len = 2;
+    size_t this_chunk_len = 2, best_chunk_len = 2;
 
     /* Loop through remaining slices */
-    while (++it != flist.end())
+    while (++it != flist->end())
     {
 	++slice_no;
 	df = (*it).get();
@@ -187,18 +320,21 @@
     }
 
     /* Report information about best chunk */
-    lprintf ("Best chunck:\n  Slices %d to %d from (0 to %d)\n"
-	"  Z_loc = %f %f\n" 
-	"  Slice spacing = %f\n", 
-	best_chunk_start, best_chunk_start + best_chunk_len - 1, slice_no, 
-	best_chunk_z_start, 
-	best_chunk_z_start + (best_chunk_len - 1) * best_chunk_diff, 
-	best_chunk_diff);
-
+    if (best_chunk_len != flist->size()) {
+        lprintf ("** Warning, inequal slice spacing detected when loading DICOM.\n");
+        lprintf ("Best chunck:\n  Slices %d to %d from (0 to %d)\n"
+            "  Z_loc = %f %f\n" 
+            "  Slice spacing = %f\n", 
+            best_chunk_start, best_chunk_start + best_chunk_len - 1, slice_no, 
+            best_chunk_z_start, 
+            best_chunk_z_start + (best_chunk_len - 1) * best_chunk_diff, 
+            best_chunk_diff);
+    }
+    
     /* Some debugging info */
 #if defined (commentout)
     lprintf ("Slices: ");
-    for (it = flist.begin(); it != flist.end(); ++it) {
+    for (it = flist->begin(); it != flist->end(); ++it) {
         df = (*it).get();
 	lprintf ("%f ", df->get_z_position());
     }
@@ -215,15 +351,15 @@
     int slices_after = 
 	ROUND_INT ((z_last - best_chunk_z_start 
 		- (best_chunk_len - 1) * best_chunk_diff) / best_chunk_diff);
-    df = (*flist.begin()).get();
+    df = (*flist->begin()).get();
     vh.clone (df->get_volume_header());
     dim[2] = slices_before + best_chunk_len + slices_after;
     vh.get_origin()[2] = best_chunk_z_start - slices_before * best_chunk_diff;
     vh.get_spacing()[2] = best_chunk_diff;
 
     /* Store image header */
-    if (d_ptr->m_drs) {
-        d_ptr->m_drs->set_image_header (Plm_image_header (vh));
+    if (d_ptr->rt_meta) {
+        d_ptr->rt_meta->set_image_header (Plm_image_header (vh));
     }
 
     /* More debugging info */
@@ -238,84 +374,6 @@
     lprintf ("\n");
 #endif
 
-    /* Divine image type */
-    df = (*flist.begin()).get();
-    uint16_t samp_per_pix, bits_alloc, bits_stored, high_bit, pixel_rep;
-    const char* phot_interp;
-    bool rc = df->get_uint16 (DCM_SamplesPerPixel, &samp_per_pix);
-    if (!rc) {
-	//return pli;
-        return;
-    }
-    phot_interp = df->get_cstr (DCM_PhotometricInterpretation);
-    if (!phot_interp) {
-	//return pli;
-        return;
-    }
-    rc = df->get_uint16 (DCM_BitsAllocated, &bits_alloc);
-    if (!rc) {
-	//return pli;
-        return;
-    }
-    rc = df->get_uint16 (DCM_BitsStored, &bits_stored);
-    if (!rc) {
-	//return pli;
-        return;
-    }
-    rc = df->get_uint16 (DCM_HighBit, &high_bit);
-    if (!rc) {
-	//return pli;
-        return;
-    }
-    rc = df->get_uint16 (DCM_PixelRepresentation, &pixel_rep);
-    if (!rc) {
-	//return pli;
-        return;
-    }
-    lprintf ("Samp_per_pix: %d\n", (int) samp_per_pix);
-    lprintf ("Phot_interp: %s\n", phot_interp);
-    lprintf ("Bits_alloc: %d\n", (int) bits_alloc);
-    lprintf ("Bits_stored: %d\n", (int) bits_stored);
-    lprintf ("High_bit: %d\n", (int) high_bit);
-    lprintf ("Pixel_rep: %d\n", (int) pixel_rep);
-
-    float rescale_slope, rescale_intercept;
-    rc = df->get_ds_float (DCM_RescaleIntercept, &rescale_intercept);
-    if (!rc) {
-        rescale_intercept = 0;
-    }
-    rc = df->get_ds_float (DCM_RescaleSlope, &rescale_slope);
-    if (!rc) {
-        rescale_slope = 1;
-    }
-
-    lprintf ("S/I = %f/%f\n", rescale_slope, rescale_intercept);
-
-    /* Some kinds of images we don't know how to deal with.  
-       Don't load these. */
-    if (samp_per_pix != 1) {
-        lprintf ("Sorry, couldn't load image: samp_per_pix\n");
-        return;
-    }
-    if (strcmp (phot_interp, "MONOCHROME2")) {
-        lprintf ("Sorry, couldn't load image: phot_interp\n");
-        return;
-    }
-    if (bits_alloc != 16 && bits_alloc != 8) {
-        lprintf ("Sorry, couldn't load image: bits_alloc\n");
-        return;
-    }
-    if (bits_stored != high_bit + 1) {
-        lprintf ("Sorry, couldn't load image: bits_stored/high_bit\n");
-        return;
-    }
-    if (pixel_rep != 0 && pixel_rep != 1) {
-        lprintf ("Sorry, couldn't load image: pixel_rep\n");
-        return;
-    }
-
-    lprintf ("Image looks ok.  Try to load.\n");
-
     pli->m_type = PLM_IMG_TYPE_GPUIT_FLOAT;
     pli->m_original_type = PLM_IMG_TYPE_GPUIT_FLOAT;
     Volume* vol = new Volume (vh, PT_FLOAT, 1);
@@ -326,10 +384,10 @@
     for (plm_long i = 0; i < dim[2]; i++) {
 	/* Find the best slice, using nearest neighbor interpolation */
 	std::list<Dcmtk_file::Pointer>::const_iterator best_slice_it 
-            = flist.begin();
+            = flist->begin();
 	float best_z_dist = FLT_MAX;
 	float z_pos = vh.get_origin()[2] + i * vh.get_spacing()[2];
-	for (it = flist.begin(); it != flist.end(); ++it) {
+	for (it = flist->begin(); it != flist->end(); ++it) {
 	    float this_z_dist = fabs ((*it)->get_z_position() - z_pos);
 	    if (this_z_dist < best_z_dist) {
 		best_z_dist = this_z_dist;
@@ -349,7 +407,7 @@
            cf. http://support.dcmtk.org/docs/mod_dcmimage.html */
 	const uint8_t* pixel_data_8;
 	const uint16_t* pixel_data_16;
-	unsigned long length;
+	unsigned long length = 0;
         rc = 0;
         if (bits_alloc == 8) {
             rc = df->get_uint8_array (DCM_PixelData, &pixel_data_8, &length);
@@ -379,12 +437,13 @@
 	img += length;
 
 	/* Store slice UID */
-        if (d_ptr->m_drs) {
-            d_ptr->m_drs->set_slice_uid (i, df->get_cstr (DCM_SOPInstanceUID));
+        if (d_ptr->rt_meta) {
+            d_ptr->rt_meta->set_slice_uid (i, df->get_cstr (DCM_SOPInstanceUID));
         }
     }
-    if (d_ptr->m_drs) {
-        d_ptr->m_drs->set_slice_list_complete ();
+#endif /* NOT VOL_LIST */
+    if (d_ptr->rt_meta) {
+        d_ptr->rt_meta->set_slice_list_complete ();
     }
 }
 
@@ -457,11 +516,9 @@
     dcmtk_copy_from_metadata (dataset, image_metadata, 
         DCM_PatientPosition, "HFS");
 
-    
-
     dataset->putAndInsertString (DCM_SeriesInstanceUID, 
         drs->get_ct_series_uid());
-    dataset->putAndInsertString (DCM_SeriesNumber, "303");
+    dcmtk_copy_from_metadata (dataset, image_metadata, DCM_SeriesNumber, "1");
     tmp = string_format ("%d", dsd->instance_no);
     dataset->putAndInsertString (DCM_InstanceNumber, tmp.c_str());
     //dataset->putAndInsertString (DCM_InstanceNumber, "0");
@@ -495,8 +552,10 @@
     //dataset->putAndInsertString (DCM_RescaleSlope, "1");
     dataset->putAndInsertString (DCM_RescaleType, "HU");
 
-    dataset->putAndInsertString (DCM_WindowCenter, "40");
-    dataset->putAndInsertString (DCM_WindowWidth, "400");
+    dcmtk_copy_from_metadata (dataset, image_metadata,
+        DCM_WindowCenter, "40");
+    dcmtk_copy_from_metadata (dataset, image_metadata,
+        DCM_WindowWidth, "400");
 
     /* Convert to 16-bit signed int */
     for (size_t i = 0; i < dsd->slice_size; i++) {
