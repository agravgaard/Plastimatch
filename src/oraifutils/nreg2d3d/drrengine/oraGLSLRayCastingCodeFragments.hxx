//

#include <string>

namespace ora
{

/**
 * This header simply includes the developed GLSL fragments for GLSL-based
 * DRR-computation as explicit shader source strings in order to
 * avoid loading them from external files during run-time (which may, however,
 * be useful for pure development).
 *
 * @see ora::GLSLDRRRayCaster
 *
 * @author phil <philipp.steininger (at) pmu.ac.at>
 * @author VTK-community
 * @version 1.5
 */

/** GLSL code for main program. **/
const std::string
    GLSL_DRR_MAIN_CODE =
          "// depth map of the polygonal geometry\n"
          "uniform sampler2D depthTexture;\n"
          "// inverse size of DRR (inverse for faster computation)\n"
          "uniform vec2 invDRRSize;\n"
          "// change-of-coordinate matrix from eye space to texture space\n"
          "uniform mat4 textureToEye;\n"
          "// entry position (global scope)\n"
          "vec3 pos;\n"
          "// incremental vector in texture space (global scope)\n"
          "vec3 rayDir;\n"
          "// abscissa along the ray of the point on the depth map\n"
          "// (tracing stop criterion: t>=tMax)\n"
          "float tMax;\n"
          "// 2D texture fragment coordinates [0;1] from fragment coordinates;\n"
          "// the frame buffer texture has the size of the plain buffer but\n"
          "// we use a fraction of it\n"
          "vec2 fragTexCoord;\n"
          "// flag indicating whether a DRR mask should be considered\n"
          "uniform float useDRRMask;\n"
          "// 3D DRR mask texture (a 2D image, however 3D representation)\n"
          "uniform sampler3D drrMaskTexture;\n"
          "// rescale slope for final pixel rescaling\n"
          "uniform float rescaleSlope;\n"
          "// rescale intercept for final pixel rescaling\n"
          "uniform float rescaleIntercept;\n"
          "// projection method (perspective projection);\n"
          "// may use pos in global scope as input.\n"
          "// may use rayDir in global scope as output\n"
          "void perspectiveRayDirection();\n"
          "// ray-casting implementation;\n"
          "// sum up the (weighted) intensities along the ray\n"
          "void rayCast();\n"
          "\n"
          "// Main program (fragment shader).\n"
          "void main()\n"
          "{\n"
          "  // device coordinates are between -1 and 1\n"
          "  // we need texture coordinates between 0 and 1\n"
          "  // the depth buffer has the original size buffer.\n"
          "  fragTexCoord = gl_FragCoord.xy * invDRRSize;\n"
          "  vec4 depth = texture2D(depthTexture,fragTexCoord);\n"
          "  // NOTE: no depth test (gl_FragCoord.z >= depth.x) because we can easily\n"
          "  // have an image size > render window size!!\n"
          "  \n"
          "  // color buffer or max scalar buffer have a reduced size.\n"
          "  // FIXME: fragTexCoord = gl_FragCoord.xy * invDRRSize;\n"
          "  // abscissa of the point on the depth buffer along the ray.\n"
          "  // point in texture coordinates\n"
          "  vec4 maxPoint;\n"
          "  \n"
          "  // from window coordinates to normalized device coordinates\n"
          "  maxPoint.x = gl_FragCoord.x * 2.0 * invDRRSize.x - 1.0;\n"
          "  maxPoint.y = gl_FragCoord.y * 2.0 * invDRRSize.y - 1.0;\n"
          "  maxPoint.z = (2.0 * depth.x - (gl_DepthRange.near + gl_DepthRange.far)) / gl_DepthRange.diff;\n"
          "  maxPoint.w = 1.0;\n"
          "  \n"
          "  // from normalized device coordinates to eye coordinates\n"
          "  maxPoint = gl_ProjectionMatrixInverse * maxPoint;\n"
          "  \n"
          "  // from eye coordinates to texture coordinates\n"
          "  maxPoint = textureToEye * maxPoint;\n"
          "  // homogeneous to cartesian coordinates\n"
          "  maxPoint /= maxPoint.w;\n"
          "  \n"
          "  // entry position; divide by q\n"
          "  pos = gl_TexCoord[0].xyz / vec3(gl_TexCoord[0].w);\n"
          "  \n"
          "  \n"
          "  int needRender = 0;\n"
          "  if (useDRRMask < 0.5)\n"
          "  {\n"
          "    needRender = 1; \n"
          "  }\n"
          "  else\n"
          "  {\n"
          "    vec4 maskValue;\n"
          "    maskValue = texture3D(drrMaskTexture, vec3(fragTexCoord.xy, 0.0));\n"
          "    if (maskValue.r > 0.5)\n"
          "      needRender = 1;\n"
          "  }\n"
          "  if (needRender == 1) //non-masked DRR content\n"
          "  {\n"
          "    // incremental perspective projection vector in texture space\n"
          "    perspectiveRayDirection();\n"
          "    \n"
          "    // ray-casting stop criterion\n"
          "    tMax = length(maxPoint.xyz - pos.xyz) / length(rayDir);\n"
          "    \n"
          "    // compute fragment color (DRR intensities) by ray-casting and\n"
          "    // successive summation of the casted intensities along the ray\n"
          "    rayCast(); \n"
          "  }\n"
          "  else //masked DRR region -> zero-output\n"
          "  {\n"
          "    gl_FragColor = vec4(vec3(rescaleIntercept), 1);\n"
          "  }\n"
          "}\n";

/** GLSL code for perspective projection (ray-direction). **/
const std::string GLSL_DRR_PERSPECTIVE_PROJECTION_CODE =
    "// entry position (global scope)\n"
      "vec3 pos;\n"
      "// incremental vector in texture space (global scope)\n"
      "vec3 rayDir;\n"
      "// source position in texture space\n"
      "uniform vec3 sourcePosition;\n"
      "// sample distance in world space (along ray)\n"
      "uniform float sampleDistance;\n"
      "// matrix coefficients: diagonal (a11, a22, a33)\n"
      "uniform vec3 matrix1;\n"
      "// matrix coefficients: others (2a12, 2a23, 2a13)\n"
      "uniform vec3 matrix2;\n"
      "\n"
      "// Perspective projection method calculating ray direction.\n"
      "void perspectiveRayDirection()\n"
      "{\n"
      "  // direction of the ray in texture space, not normalized.\n"
      "  rayDir = pos - sourcePosition;\n"
      "  \n"
      "  // x^2, y^2, z^2\n"
      "  vec3 normDir = rayDir * rayDir;\n"
      "  normDir.x = dot(normDir, matrix1);\n"
      "  \n"
      "  // xy, yz, zx\n"
      "  vec3 coefs = rayDir * rayDir.yxz;\n"
      "  coefs.x = dot(coefs, matrix2);\n"
      "  \n"
      "  // n^2\n"
      "  normDir.x = normDir.x + coefs.x;\n"
      "  \n"
      "  // 1/n\n"
      "  normDir.x = inversesqrt(normDir.x);\n"
      "  \n"
      "  // final scale factor for the ray direction in texture space\n"
      "  normDir.x = normDir.x * sampleDistance;\n"
      "  // now, rayDir is the incremental direction in texture space\n"
      "  rayDir = rayDir * normDir.x;\n"
      "}\n";

/** GLSL code for ray-casting. **/
const std::string
    GLSL_DRR_RAY_CASTING_CODE =
        "// Digitally Reconstructed Radiograph (DRR) computation.\n"
          "// It executes ray-casting by simple summation of the casted intensities found\n"
          "// along the corresponding ray dictated by the perspective projection method.\n"
          "// It supports an intensity transfer function which maps the (normalized) 3D\n"
          "// volume intensities to output factors which contribute to the DRR.\n"
          "\n"
          "// 3D volume texture\n"
          "uniform sampler3D dataSetTexture;\n"
          "// intensity transfer function\n"
          "uniform sampler1D transferFunc;\n"
          "// 3D volume lower bounds\n"
          "uniform vec3 lowBounds;\n"
          "// 3D volume higher bounds\n"
          "uniform vec3 highBounds;\n"
          "// entry position (global scope)\n"
          "vec3 pos;\n"
          "// incremental vector in texture space (global scope)\n"
          "vec3 rayDir;\n"
          "// abscissa along the ray of the point on the depth map\n"
          "// (tracing stop criterion: t>=tMax)\n"
          "float tMax;\n"
          "// rescale slope for final pixel rescaling\n"
          "uniform float rescaleSlope;\n"
          "// rescale intercept for final pixel rescaling\n"
          "uniform float rescaleIntercept;\n"
          "\n"
          "// Ray-casting implementation with ITF-usage.\n"
          "void rayCast(void)\n"
          "{\n"
          "  float sum = 0.0; // shader's 2D DRR pixel sum value\n"
          "  bool inside = true; // stop criterion\n"
          "  vec4 sample; // 3D volume sample\n"
          "  float t = 0.0; // current abscissa along projection ray\n"
          "  \n"
          "  // 2 nested while loops (work around hardware limitation about max no. loops)\n"
          "  while (inside)\n"
          "  {\n"
          "    while (inside)\n"
          "    {\n"
          "      // get 3D volume sample for current position (only the red channel is used\n"
          "      // which contains the volume intensities), map it through the intensity\n"
          "      // transfer function and sum it up: \n"
          "      sample = texture3D(dataSetTexture, pos); \n"
          "      sum += texture1D(transferFunc, sample.r); \n"
          "      \n"
          "      // update current position and abscissa:\n"
          "      pos += rayDir;\n"
          "      t += 1.0;\n"
          "      \n"
          "      // evaluate stop criterion: position check w.r.t. abscissa and volume bounds:\n"
          "      inside = (t < tMax && pos.x >= lowBounds.x && pos.y >= lowBounds.y &&\n"
          "        pos.z >= lowBounds.z && pos.x <= highBounds.x && \n"
          "        pos.y <= highBounds.y && pos.z <= highBounds.z);\n"
          "    }\n"
          "  }\n"
          "  \n"
          "  sum = sum * rescaleSlope + rescaleIntercept; // final rescaling\n"
          "  \n"
          "  // write DRR value (fragment color);\n"
          "  // apply summed intensity to all 3 channels\n"
          "  gl_FragColor = vec4(vec3(sum), 1);\n"
          "}\n";

}
